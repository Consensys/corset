* Corset

Corset is a Lisp-based DSL designed to modelize constraint systems in the context of zero-knowledge proof systems. It aims at simplifying the writing and understanding of complicated, intricate, commitments by abstracting over cryptographic polynomial primitives; all the while letting users work at their preferred granularity level.

* Installation
The only dependency to run Corset is [[https://www.rust-lang.org/][the Rust compiler]]. Once it is available, Corset can be installed with ~cargo install --git https://github.com/ConsenSys/corset~; or, within a local copy of the repo: ~cargo install --path .~
* Usage
Corset is a simple Lisp dialect, compiling expressions to a representation compatible with a polynomial cryptographic proof system featuring the following operations: ~Add~, ~Mul~, ~Sub~, ~Neg~, and ~Inv~.

** Command Line Interface
#+begin_src
USAGE:
    corset [OPTIONS] [SOURCE]... <SUBCOMMAND>

ARGS:
    <SOURCE>...    Either a file or a string containing the Corset code to process

OPTIONS:
    -h, --help              Print help information
        --no-stdlib
    -o, --out <OUT_FILE>    If set, write the result to this file
    -V, --version           Print version information

SUBCOMMANDS:
    go       Produce a Go-based constraint system
    help     Print this message or the help of the given subcommand(s)
    latex    Produce a LaTeX file describing the constraints=
#+end_src

** General Concept
A program takes the form of a list of lisp-like expression written in the Corset dialect of lisp, that are then parsed as a list of constraint lisp and compiled as a succession of constraints expressed as composition of the aforementioned base functions.

Once formalized by the Corset compiler, these "programs" can then be exported to any backend – althoug for now, only Go exporting is implemented.

* Programming in Corset
** General Form of a Corset Program
A Corset program is defined as a succession of top-level forms. Each of these form define a pieve of the final program, which can be a *column*, a *natural integer*, a *function*, an *alias*, or a *constraint*.

*** Columns
Columns are the basic building block of Corset programs, as they represent the values that the constraint system will be check against. Columns are defined with the ~defcolumns~ keyword, and can be either *scalar* or *composite* (/i.e./ array-like).

Column arrays are typically used to group semantically similar columns, /e.g./ high & low decomposition.

#+begin_src lisp
  ;; Columns can be defined one at a time...
  (defcolumns ALPHA)
  (defcolumns BETA)

  ;; ..or several at once
  (defcolumns
    GAMMA DELTA EPSILON
    X Y Z)

  ;; Columns can be scalar...
  (defcolumns VALUE)
  (defconstraint () pipo (eq VALUE 3))

  ;; ...or array-like
  (defcolumns VALUES[5])

  ;; Array domains can be defined using several syntaxes
  (defcolumns
    EXAMPLE1[2]       ;; EXAMPLE1 is defined over {1, 2}
    EXAMPLE2[4:7]     ;; EXAMPLE2 is defined over {4, 5, 6, 7}
    EXAMPLE3[2:10:2]  ;; EXAMPLE3 is defined over {2, 4, 6, 8, 10}
    EXAMPLE4{1 6 8})  ;; EXAMPLE4 is defined over {1, 6, 8}

  ;; Array columns are indexed using the (nth) function
  (defconstraint foo ()
    (eq (nth EXAMPLE1 2) (nth EXAMPLE4 6)))

  ;; Array accesses are checked at compile time
  (defconstraint will-fail ()
    (nth EXAMPLE4 2)) ;; 2 ∉ {1, 6, 8}
#+end_src
*** Functions
Functions can be defined to factorize common cosntraint operations. This is done using the ~defun~ form, specifying the name of the function and its (optional) parameters.
#+begin_src lisp
  (defcolumns A B C[3])

  ;; Checks that X == Y == Z
  (defun (eq3 X Y Z)
      (and (eq X Y)
           (eq Y Z)))

  ;; A == B == C[2]
  (defconstraint alpha ()
    (eq3 A B (nth C 2)))


  (defun (large-operation T U V i k)
      (begin
       (some-big-constraint T k)
       (some-other-constraint U V i)))

  ;; Factorize big constraints
  (defconstraint () beta
    (begin
     (large-operation A (nth C 1))
     (large-operation A (nth C 3))
     (large-operation A (nth C 2))))

  ;; Functions can be combined with for
  (defconstraint () beta-prime
    (for i [3]
         (large-operation A (nth C i))))
#+end_src
*** Aliases
Aliases create new bindings of an existing column or function under a new name. While the aliased object behave xactly as its target, it may prove easier to read in certain contexts.
**** Columns Aliases
Column aliases are defined using the ~defalias~ function, which takes one or more pairs of ~ALIAS TARGET~ pairs.
#+begin_src lisp
  (defcolumn T)
  (defalias U T)
  ;; U now behaves like T

  (defcolumns A B C)
  (defalias
    X A
    Y B
    Z C)
  ;; (X, Y, Z) now behave like (A, B, C)
#+end_src
**** Functions Aliases
Functions aliases, defined using the ~defunalias~ function, works the same way as column aliases, but act on functions instead of columns.
#+begin_src lisp
  (defcolumns A B)

  (defunalias minus sub)
  ;; minus now behaves just like sub
  (defconstraint () always-true
    (eq (sub A B) (minus A B)))
#+end_src
*** Constraints
Constraints are the parts of a Corset program that will be compiled and featured in the final product, and represent an epxression of the defined columns that should alway evaluate to 0. Their definition follow the syntax ~(defconstraint DOMAIN NAME EXPRESSION)~.

The ~DOMAIN~ is a list of evaluation points where ~EXPRESSION~ must hold true. If it is empty, then ~EXPRESSION~ must hold for its whole definition domain.

Here is a simple example, establishing that columns ~A~ and ~B~ must always be equal:
#+begin_src lisp
  (defcolumns A B)
  (defconstraint A-equals-B () (= A B))
  (defconstraint A-equals-B-somewhere (1 3 5) (= A B))
#+end_src



*** Special Forms
/Special forms/ are syntactically identical to functions, but are built in the compiler, and thus fill the role of exposing the primitives of the language in a safe and ergonomic way.
**** ~nth~
The ~nth~ function is used to access the element of a column array.
#+begin_src lisp
  (defcolumns A B[1:3])

  (defconstraint foo (1 2)
    (eq A (nth B 2)))

  ;; Creates a function accessin the i-th element of B
  (defun (nth-B i) (nth B i))

  (defconstraint bar ()
    (eq A (nth-B 2)))
#+end_src
**** ~begin~
The ~begin~ forms define a list of conditions that should all be verified. They are useful /e.g./ in function definnitions or within ~if~ branches.
#+begin_src lisp
  (defcolumns A B C)


  (defconstraint foo ()
    (begin  ;; the two following constraints must be verfiied
     (eq A B)
     (eq A C)))

  (defun (two-change X Y)
      (begin
       (did-change X)
       (did-change Y)))

  (defconstraint bar ()
    (two-change A B))
#+end_src
**** ~for~
The ~for~ forms generate similar constraints, parametrized by the specified iteration variable, ranging over the provided range.
#+begin_src lisp
  (defcolumns A[4] C[2:4])


  ;; Range syntax is identical to the one used in DEFCOLUMNS
  ;; ∀i, A[i] = i
  (defconstraint alpha ()
    (for i [4] (eq (nth A i) i)))


  (defun (same-at-i X Y i)
      (eq (nth X i) (nth Y i)))

  ;; A[2] = C[2] && A[4] = C[4]
  (defconstraint beta ()
    (for i {2 4} (same-at-i A C i)))

  ;; For forms can be nested
  ;; A[1, 3] ⨯ C[2, 4] = constant
  (defconstraint gamma ()
    (for i [1:4:2]
         (for j {2 4}
              (eq (nth A i) (nth C j)))))

#+end_src
** The Standard library
Unless specified otherwise (by using the ~--no-stdlib~ flag when invoking the Corset compiler), Corset provides a set of base functions.
*** Boolean Operators
The boolean operators work under the assumption that their operands are binary.
  - ~(not x)~
  - ~(eq x y)~
  - ~(neq x y)~
  - ~(and x y)~
  - ~(or x y)~
  - ~(xor x y)~
  - ~(is-binary x)~
*** Branching Forms
Corset features several branching operations. Although they ought to be simplified in coming revisions of Corset, they are still quite clumsy.
**** Branching Forms
Branching forms reproduce the classical ~if COND then A [else B]~ scheme. If ~A~ or ~B~ contain several several sub-statements, then they must be wrapped in a ~begin~ form.
***** Binary Forms
The behavior of these forms is only guaranteed if ~COND~ is binary.
  - ~(bin-if-zero COND A)~
  - ~(bin-if-one COND A)~
  - ~(bin-if-zero-else COND A B)~
  - ~(bin-if-one-else COND A B)~
***** Generic Forms
The behavior of these forms is defined in any case, but they are less performant than their ~-binary~ counterpart.
  - ~(if-zero COND A [B])~
  - ~(if-not-zero COND A [B])~

*** Chronological Operations
Chronological operations define constraints on the temporal evolution of a column.
  - ~(did-change x)~ ensures that $X_{i-1} \neq X_i$
  - ~(didnt-change x)~ (or ~remains-constant~) ensures that $X_{i-1} = X$
  - ~(will-eq x y)~ ensures that $X_{i+1} = Y$
  - ~(was-eq x y)~ ensures that $X_{i-1} = Y$
  - ~(inc x k)~ ensures that $X_{i+1} = X_i + k$
  - ~(dec x k)~ ensures that $X_{i+1} = X_i - k$

** Interfacing Corset
*** With Go
By default, the Go exporter of Corset will produce a function per constraint, and an additional public function, whose name is specified with the ~-F/--function-name~ switch, concatenating all the other ones.

All the functions are generated in the package specified with ~-P/--package~, ready to be integrated with your go code.

To automatically compile Corset constraints, the ~~go generate~ feature can be leveraged; for instance:
#+begin_src go
//go:generate corset -F stackExceptionsConstraints -P hub --out ./stackEx.go stackEx.lisp
#+end_src

* Corset Examples
** General Example of a Corset Program
#+begin_src lisp
  ;; User-defined function
  (defun (vanishes x) x)

  ;; List the columns used
  (defcolumns
    ALPHA DELTA
    HEIGHT HEIGHT_UNDER HEIGHT_OVER
    STACK_EXCEPTION STACK_UNDERFLOW_EXCEPTION STACK_OVERFLOW_EXCEPTION)

  ;; Define aliases for some columns
  (defalias HU HEIGHT_UNDER)
  (defalias HO HEIGHT_OVER)
  (defalias SUX STACK_UNDERFLOW_EXCEPTION)
  (defalias SOX STACK_OVERFLOW_EXCEPTION)
  (defalias SEX STACK_EXCEPTION)

  ;; Implements HU = (2*SUX - 1)*(DELTA - HEIGHT) - SUX
  (defconstraint height-under ()
    (= HU
       (- (* (- (* 2 STACK_UNDERFLOW_EXCEPTION) 1)
             (- DELTA HEIGHT))
          STACK_UNDERFLOW_EXCEPTION)))

  ;; SUX and SOX are mutually exclusive
  (defconstraint sux-xor-sox ()
    (bin-if-one STACK_UNDERFLOW_EXCEPTION STACK_OVERFLOW_EXCEPTION))

  ;; (SUX == 0) ==> HO = (2*SOX - 1)*(HEIGHT_UNDER + ALPHA - 1024) - SOX
  (defconstraint sux-0 ()
    (vanishes
     (if-zero SUX (= HO (- (* (- (* 2 SOX) 1)
                              (- (+ HU ALPHA) 1024))
                           SOX)))))

  ;; If SUX or SOX is set, then SEX is set; and they are mutually exclusive
  (defconstraint ifSuxOrSoxThenSex ()
    (= SEX (+ SOX SUX)))
#+end_src
