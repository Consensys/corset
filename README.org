* Corset
Corset is a Lisp-based DSL designed to implement constraint systems in the context of zero-knowledge proof systems. It aims at simplifying the writing and understanding of complicated, intricate, commitments by abstracting over cryptographic polynomial primitives; all the while letting users work at their preferred granularity level.

It offers all the tools to:
1. implement constraint system in a high-level, dynamically but strongly typed dialect of Lisp;
2. parse, compile down to polynomial arithmetic, and serialize constraint systems written in Corset Lisp;
3. export those constraint systems in many formats, from Go to LaTeX;
4. check & debug traces against a compiled constraint system.
* Installation
The only dependency to run Corset is [[https://www.rust-lang.org/][the Rust compiler]]. Once it is available, Corset can be installed with ~cargo install --git https://github.com/ConsenSys/corset~; or, within a local copy of the repo: ~cargo install --path .~
* Usage
Corset is a simple Lisp dialect, compiling expressions to a representation compatible with a polynomial cryptographic proof system featuring the following operations: ~Add~, ~Mul~, ~Sub~, ~Neg~, and ~Inv~.

** Command Line Interface
#+begin_src
USAGE:
    corset [OPTIONS] [SOURCE]... <SUBCOMMAND>

ARGS:
    <SOURCE>...    Either a file or a string containing the Corset code to process

OPTIONS:
    -C, --columns                                    whether to render columns definition
        --columns-file <COLUMNS_FILENAME>            where to render the columns
    -E, --expand                                     if true, expand INV computations
    -h, --help                                       Print help information
        --no-stdlib
    -o, --constraints-file <CONSTRAINTS_FILENAME>    where to render the constraints
    -V, --version                                    Print version information

SUBCOMMANDS:
    compute
    go         Produce a Go-based constraint system
    help       Print this message or the help of the given subcommand(s)
    latex      Produce a LaTeX file describing the constraints
#+end_src

** General Concept
A program takes the form of a list of lisp-like expression written in the Corset dialect of lisp, that are then parsed as a list of constraint lisp and compiled as a succession of constraints expressed as composition of the aforementioned base functions.

Once formalized by the Corset compiler, these "programs" can then be exported to any backend – althoug for now, only Go exporting is implemented.

* Programming in Corset
** General Form of a Corset Program
A Corset program is defined as a succession of top-level forms. Each of these form define a pieve of the final program, which can be a *column*, a *constant*, a *function*, an *alias*, or a *constraint*.
*** Columns
Columns are the basic building block of Corset programs, as they represent the values that the constraint system will be checked against. Columns are defined with the ~defcolumns~ keyword, and can be either *scalar* or *composite* (/i.e./ array-like). All the elements of a column can be *integer* (/i.e./ field elements), *bytes* (integers in the 0-255 range), *nibbles* (integers in the 0-32 range) or *booleans*.

#+begin_src lisp
  ;; Columns can be defined one at a time...
  (defcolumns ALPHA)
  (defcolumns BETA)

  ;; ..or several at once
  (defcolumns
    GAMMA DELTA EPSILON
    X Y Z)

  ;; Columns may have a stype
  (defcolumns A (B :BOOLEAN) (C :NIBBLE))

  ;; Columns can be scalar...
  (defcolumns VALUE)
  (defconstraint () pipo (eq VALUE 3))

  ;; ...or array-like
  (defcolumns (VALUES :ARRAY[5]))

  ;; Array domains can be defined using several syntaxes
  (defcolumns
    (EXAMPLE1[2])       ;; array size:       EXAMPLE1 is defined over {1, 2}
    (EXAMPLE2[4:7])     ;; start:end:        EXAMPLE2 is defined over {4, 5, 6, 7}
    (EXAMPLE3[2:10:2])  ;; start:end:step:   EXAMPLE3 is defined over {2, 4, 6, 8, 10}
    (EXAMPLE4{1 6 8}))  ;; diescrete domain: EXAMPLE4 is defined over {1, 6, 8}

  ;; Array columns are indexed using the nth function
  (defconstraint foo ()
    (eq (nth EXAMPLE1 2) (nth EXAMPLE4 6)))

  ;; Array accesses are checked at compile time
  (defconstraint will-fail ()
    (nth EXAMPLE4 2)) ;; 2 ∉ {1, 6, 8}
#+end_src
*** Functions
Functions can be defined to factorize common operations. This is done using the ~defun~ form, specifying the name of the function and its (optional) parameters.
#+begin_src lisp
  (defcolumns A B C[3])

  ;; Checks that X == Y == Z
  (defun (eq3 X Y Z)
      (and (eq X Y)
           (eq Y Z)))

  ;; A == B == C[2]
  (defconstraint alpha ()
    (eq3 A B (nth C 2)))


  (defun (large-operation T U V i k)
      (begin
       (some-big-constraint T k)
       (some-other-constraint U V i)))

  ;; Factorize big constraints
  (defconstraint () beta
    (begin
     (large-operation A (nth C 1))
     (large-operation A (nth C 3))
     (large-operation A (nth C 2))))

  ;; Functions can be combined with for
  (defconstraint () beta-prime
    (for i [3]
         (large-operation A (nth C i))))
#+end_src
**** Pure Functions
Functions close over their environment, and thus capture or shadow columns accessible from their declaration point, which are available within the body, along the function parameters.

In contrats, *pure functions* can only operate on their arguments and constants, thus ensuring that no shadowing or other surprising behavior ever happen.

#+begin_src lisp
  (defconstant W 10)
  (defcolumns A)

  (defpurefun (f X) (eq X W)) ;; OK
  (defpurefun (f X) (eq X A)) ;; KO: f can not access A
#+end_src
*** Aliases
Aliases create new bindings of an existing column or function under a new name. While the aliased object behave xactly as its target, it may prove easier to read in certain contexts.
**** Columns Aliases
Column aliases are defined using the ~defalias~ function, which takes one or more pairs of ~ALIAS TARGET~ pairs.
#+begin_src lisp
  (defcolumn T)
  (defalias U T)
  ;; U now behaves like T

  (defcolumns A B C)
  (defalias
    X A
    Y B
    Z C)
  ;; (X, Y, Z) now behave like (A, B, C)
#+end_src
**** Functions Aliases
Functions aliases, defined using the ~defunalias~ function, works the same way as column aliases, but act on functions instead of columns.
#+begin_src lisp
  (defcolumns A B)

  (defunalias minus sub)
  ;; minus now behaves just like sub
  (defconstraint () always-true
    (eq (sub A B) (minus A B)))
#+end_src
*** Constraints
Constraints are the parts of a Corset program that will be compiled and featured in the final product, and represent an epxression of the defined columns that should alway evaluate to 0. Their definition follow the syntax ~(defconstraint NAME (LIMITERS) EXPRESSION)~.

The ~LIMITERS~ is a list of conditions limiting where the constraint must hold true. If it is empty, then ~EXPRESSION~ must hold for its whole definition domain. The available limiters are:
  - ~:domain RANGE~ :: a range that specifies a finite set of positions where the constraint must hold true; /e.g./ ={0 -1}=;
  - ~:guard EXPRESSION~ :: an expression defining the domain of the constraint: it must only hold when ~EXPRESSION~ is non-zero.

Here is a simple example, establishing that columns ~A~ and ~B~ must always be equal:
#+begin_src lisp
  (defcolumns A B)
  (defconstraint A-equals-B () (= A B)) ;; this constraint must be verified everywhere
  (defconstraint A-equals-B-somewhere (:domain {1 3 5}) (= A B)) ;; this constraint only holds at lines 1, 3, & 5
  (defconstraint A-equals-B-sometimes (:guard (eq INST 32)) (= A B)) ;; this constraint only holds if INST == 32
#+end_src
*** Modules
In order to avoid name conflicts, Corset offers an optional module system allowing the use of the same symbol name in different contexts.
#+begin_src lisp
  (defcolumns A B)
  (defconstraint foo (eq A B))

  (module shabang) ;; we are now in the namespace of shabang
  (defconstraint foobar (eq A B)) ;; will fail: A & B do not exist here

  (defcolumns A B) ;; A & B now exist in shabang, distinct from the previously declared A & B
  (defconstraint foobar (eq A B)) ;; will now work
#+end_src

** The Standard library
Unless specified otherwise (by using the ~--no-stdlib~ flag when invoking the Corset compiler), Corset provides a set of base functions.
*** Boolean Operators
The boolean operators work under the assumption that their operands are binary.
  - ~(not x)~
  - ~(eq x y)~
  - ~(neq x y)~
  - ~(and x y)~
  - ~(or x y)~
  - ~(xor x y)~
  - ~(is-binary x)~
*** Special Forms
**** ~nth~
The ~nth~ function is used to access the element of a column array.
#+begin_src lisp
  (defcolumns A B[1:3])

  (defconstraint foo (1 2)
    (eq A (nth B 2)))

  ;; Creates a function accessin the i-th element of B
  (defun (nth-B i) (nth B i))

  (defconstraint bar ()
    (eq A (nth-B 2)))
#+end_src
**** ~begin~
The ~begin~ forms define a list of conditions that should all be verified. They are useful /e.g./ in function definnitions or within ~if~ branches.
#+begin_src lisp
  (defcolumns A B C)

  (defconstraint foo ()
    (begin  ;; the two following constraints must be verfiied
     (eq A B)
     (eq A C)))

  (defun (two-change X Y)
      (begin
       (did-change X)
       (did-change Y)))

  (defconstraint bar ()
    (two-change A B))
#+end_src
It should be noted that ~begin~ will automatically flatten its argument; /i.e./ if one of its argument is already a ~begin~ form, then its element will be added piecewise to the outer ~begin~ instead of forming a list containing another list.
**** ~for~
The ~for~ forms generate similar constraints, parametrized by the specified iteration variable, ranging over the provided range.
#+begin_src lisp
  (defcolumns A[4] C[2:4])


  ;; Range syntax is identical to the one used in DEFCOLUMNS
  ;; ∀i, A[i] = i
  (defconstraint alpha ()
    (for i [4] (eq (nth A i) i)))


  (defun (same-at-i X Y i)
      (eq (nth X i) (nth Y i)))

  ;; A[2] = C[2] && A[4] = C[4]
  (defconstraint beta ()
    (for i {2 4} (same-at-i A C i)))

  ;; For forms can be nested
  ;; A[1, 3] ⨯ C[2, 4] = constant
  (defconstraint gamma ()
    (for i [1:4:2]
         (for j {2 4}
              (eq (nth A i) (nth C j)))))

#+end_src

*** Branching Forms
Corset features several branching operations. Although they ought to be simplified in coming revisions of Corset, they are still quite clumsy.
**** Branching Forms
Branching forms reproduce the classical ~if COND then A [else B]~ scheme. If ~A~ or ~B~ contain several several sub-statements, then they must be wrapped in a ~begin~ form.
***** Binary Forms
The behavior of these forms is only guaranteed if ~COND~ is binary.
  - ~(bin-if-zero COND A [B])~
  - ~(bin-if-not-zero COND A [B])~
***** Generic Forms
The behavior of these forms is defined in any case, but they are less performant than their ~-binary~ counterpart.
  - ~(if-zero COND A [B])~
  - ~(if-not-zero COND A [B])~

*** Chronological Operations
Chronological operations define constraints on the temporal evolution of a column.
  - ~(did-change x)~ ensures that $X_{i-1} \neq X_{i}$
  - ~(didnt-change x)~ (or ~remains-constant~) ensures that $X_{i-1} = X$
  - ~(will-eq x y)~ ensures that $X_{i+1} = Y$
  - ~(was-eq x y)~ ensures that $X_{i-1} = Y$
  - ~(inc x k)~ ensures that $X_{i+1} = X_{i} + k$
  - ~(dec x k)~ ensures that $X_{i+1} = X_{i} - k$

*** PLookups
PLookup constraints are defined using the ~defplookup~ form, which takes two lists of columns or column expressions that must be included one in the other, following this format:
#+begin_src lisp
  (defcolumns A B C P Q R)

;; (defplookup NAME (parents...) (children...))
  (defplookup plookup-1 (A C) (Q R))
  (defplookup another-name (A B) ((* 2 Q) (+ Q R)))
#+end_src

* Compiling Constraint Systems
Although Corset can simply dynamically recompile programs on every invocation, it is much faster to compile a constraint system to a single file and reuse it for later invocations.

This is accomplished with the ~compile~ subcommand:
#+begin_src
Usage: corset compile [OPTIONS] --out <OUTFILE> [SOURCE]...

Arguments:
  [SOURCE]...  Either a file or a string containing the Corset code to process

Options:
  -o, --out <OUTFILE>      compiled Corset file to create
  -v, --verbose...         More output per occurrence
  -q, --quiet...           Less output per occurrence
      --debug              Compile code in debug mode
      --allow-dups         Whether to allow re-declaration of symbols
  -t, --threads <THREADS>  number of threads to use [default: 1]
  -h, --help               Print help information
  -V, --version            Print version information
#+end_src
* Checking Traces
Corset can be used to ensure that a trace, or a set of columns, actually satisfies the constraints defined in a Corset program, using the ~check~ command.
#+begin_src
  Usage: corset check [OPTIONS] --trace <TRACEFILE> [SOURCE]...

Arguments:
  [SOURCE]...  Either a file or a string containing the Corset code to process

Options:
  -T, --trace <TRACEFILE>        the trace to compute & verify
  -v, --verbose...               More output per occurrence
  -F, --trace-full               print all the module columns on error
  -q, --quiet...                 Less output per occurrence
      --debug                    Compile code in debug mode
  -E, --expand                   perform all expansion operations before checking
      --allow-dups               Whether to allow re-declaration of symbols
      --no-abort                 continue checking a constraint after it met an error
      --only <ONLY>              only check these constraints
  -t, --threads <THREADS>        number of threads to use [default: 1]
      --skip <SKIP>              skip these constraints
  -S, --trace-span <TRACE_SPAN>  [default: 3]
  -h, --help                     Print help information
  -V, --version                  Print version information
#+end_src
* Exporting Corset Constraint Systems
Corset programs can be exported in multiple formats. For now, backends are provided to export in LaTeX, in zkGeth-compatible go, or in Wizard-IOP go.
* An Example
** General Example of a Corset Program
#+begin_src lisp
  ;; User-defined function
  (defun (vanishes x) x)

  ;; List the columns used
  (defcolumns
    ALPHA DELTA
    HEIGHT HEIGHT_UNDER HEIGHT_OVER
    STACK_EXCEPTION STACK_UNDERFLOW_EXCEPTION STACK_OVERFLOW_EXCEPTION)

  ;; Define aliases for some columns
  (defalias
    HU HEIGHT_UNDER
    HO HEIGHT_OVER
    SUX STACK_UNDERFLOW_EXCEPTION
    SOX STACK_OVERFLOW_EXCEPTION
    SEX STACK_EXCEPTION)

  ;; Implements HU = (2*SUX - 1)*(DELTA - HEIGHT) - SUX
  (defconstraint height-under ()
    (= HU
       (- (* (- (* 2 STACK_UNDERFLOW_EXCEPTION) 1)
             (- DELTA HEIGHT))
          STACK_UNDERFLOW_EXCEPTION)))

  ;; SUX and SOX are mutually exclusive
  (defconstraint sux-xor-sox ()
    (if-non-zero STACK_UNDERFLOW_EXCEPTION
                 STACK_OVERFLOW_EXCEPTION))

  ;; (SUX == 0) ==> HO = (2*SOX - 1)*(HEIGHT_UNDER + ALPHA - 1024) - SOX
  (defconstraint sux-0 ()
    (vanishes (if-zero SUX (= HO (- (* (- (* 2 SOX) 1)
                                       (- (+ HU ALPHA) 1024))
                                    SOX)))))

  ;; If SUX or SOX is set, then SEX is set; and they are mutually exclusive
  (defconstraint ifSuxOrSoxThenSex ()
    (= SEX
       (+ SOX SUX)))
#+end_src
